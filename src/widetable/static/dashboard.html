<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .links line {
        stroke: #aaa;
    }

    .nodes circle {
        pointer-events: all;
        stroke: none;
        stroke-width: 40px;
    }

    html {
        font-family: sans-serif;
        font-size: 12px;
    }

</style>
<svg id="session{{session_id}}" width="800" height="800"></svg><br>
<div id="session{{session_id}}schema"></div>

<script src="https://d3js.org/d3.v5.min.js"></script>
<script>
    function getMaxComputedTextLength(trueTypeOf) {
        let max = 0
        for (let i = 0; i < this.parentNode.childNodes.length; i++) {
            if (trueTypeOf(this.parentNode.childNodes[i]) === 'svggelement') {
                max = getMaxTextLength(this.parentNode.childNodes[i], trueTypeOf, max);
            } else if (trueTypeOf(this.parentNode.childNodes[i]) === 'svgtextelement'
                && this.parentNode.childNodes[i].getComputedTextLength() > max) {
                max = this.parentNode.childNodes[i].getComputedTextLength()
            }
        }
        return max + 20
    }

    function getMaxTextLength(nodes, trueTypeOf, max) {
        for (let i = 0; i < nodes.childNodes.length; i++) {
            if (trueTypeOf(nodes.childNodes[i]) === 'svgtextelement'
                && nodes.childNodes[i].getComputedTextLength() > max) {
                max = nodes.childNodes[i].getComputedTextLength()
            }
        }
        return max;
    }

    function getMaxComputedFromParents(trueTypeOf) {
        let max = 0
        //searching grand parent's level
        max = getMaxTextLength(this.parentNode.parentNode, trueTypeOf, max);
        //searching parent's level
        max = getMaxTextLength(this.parentNode, trueTypeOf, max);
        return max + 20
    }


    console.log(d3)
    graph = {
        "nodes": {{nodes}},
        "links": {{links}}
    }
    // for dev and testing
    // graph.nodes = JSON.parse('[{"id":"orders","name":"orders","measurements":[],"attributes":["o_orderpriority","o_comment","o_totalprice","o_custkey","o_orderdate","o_shippriority","o_orderkey","o_clerk","o_orderstatus"],"join_keys":["o_orderkey"]},{"id":"lineitem","name":"lineitem","measurements":[],"attributes":["l_receiptdate","l_comment","l_quantity","l_partkey","l_orderkey","l_linenumber","l_tax","l_extendedprice","l_returnflag","l_suppkey","l_shipinstruct","l_shipdate","l_linestatus","l_commitdate","l_shipmode","l_discount"],"join_keys":["l_orderkey","l_suppkey","l_partkey"]},{"id":"partsupp","name":"partsupp","measurements":[{"name":"SUM(partsupp.ps_availqty)","relations":[{"name":"orders","should_highlight":"False","color":"None"},{"name":"lineitem","should_highlight":"False","color":"None"},{"name":"partsupp","should_highlight":"True","color":"None"},{"name":"part","should_highlight":"False","color":"None"}],"edges":[{"left_rel":"orders","right_rel":"lineitem","should_highlight":"False","color":"None"},{"left_rel":"lineitem","right_rel":"partsupp","should_highlight":"False","color":"None"},{"left_rel":"partsupp","right_rel":"part","should_highlight":"False","color":"None"}]}],"attributes":["SUM(partsupp.ps_availqty)","ps_comment","ps_availqty","ps_suppkey","ps_supplycost","ps_partkey"],"join_keys":["ps_suppkey","ps_partkey"]},{"id":"part","name":"part","measurements":[{"name":"SUM(part.p_retailprice)","relations":[{"name":"orders","should_highlight":"True","color":"None"},{"name":"lineitem","should_highlight":"True","color":"None"},{"name":"partsupp","should_highlight":"True","color":"None"},{"name":"part","should_highlight":"True","color":"None"}],"edges":[{"left_rel":"orders","right_rel":"lineitem","should_highlight":"True","color":"None"},{"left_rel":"lineitem","right_rel":"partsupp","should_highlight":"True","color":"None"},{"left_rel":"partsupp","right_rel":"part","should_highlight":"True","color":"None"}]}],"attributes":["SUM(part.p_retailprice)","p_name","p_type","p_container","p_comment","p_size","p_retailprice","p_partkey","p_brand","p_mfgr"],"join_keys":["p_partkey"]}]')
    // graph.links = JSON.parse('[{"source":"orders","target":"lineitem","left_keys":["o_orderkey"],"right_keys":["l_orderkey"],"multiplicity":["1","M"]},{"source":"lineitem","target":"partsupp","left_keys":["l_suppkey","l_partkey"],"right_keys":["ps_suppkey","ps_partkey"],"multiplicity":["M","1"]},{"source":"partsupp","target":"part","left_keys":["ps_partkey"],"right_keys":["p_partkey"],"multiplicity":["M","1"]}]')

    var svg = d3.select("#session{{session_id}}"), width = +svg.attr("width"),
        height = +svg.attr("height");

    var defaultAttrWidth = 60
    var attrHeight = 30
    const linkDistance = 300
    let buffer = 100
    // TODO: calculate based on maxAttrWidth instead of defaultAttrWidth
    width = Math.max(800, (defaultAttrWidth + linkDistance/2) * graph.nodes.length + buffer)
    svg.attr('width', width)

    function findMaxNumAttributes() {
        let maxNumAttributes = 0
        for (let i = 0; i < graph.nodes.length; i++) {
            if (graph.nodes[i].attributes.length > maxNumAttributes) {
                maxNumAttributes = graph.nodes[i].attributes.length
            }
        }
        return maxNumAttributes;
    }

    let maxNumAttributes = findMaxNumAttributes();
    height = Math.max(800, (attrHeight + linkDistance/10)* maxNumAttributes + buffer)
    svg.attr('height', height)
    svg.on("mousedown", function() {
        //reset all highlighting if background is clicked
        resetHighlightingToDefault();
    })

    var schemaarea = d3.select("#session{{session_id}}schema")

    const defaultMeasurementColor = '#8cfb14';
    const defaultJoinKeyColor = '#ef8058';

    var trueTypeOf = (obj) => Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()

    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function (d) {
            return d.id;
        }))
        .force("charge", d3.forceManyBody().strength(-280))
        .force("center", d3.forceCenter(width / 2, height / 2));

    //list of link containers

    var linkContainers = svg.append('g').attr('class', 'links')
        .selectAll("g")
        .data(graph.links)
        .enter()
        .append("g")
        .attr('id', function (d) {
            return 'link_container_' + d.source + '-' + d.target
        });

    var link = linkContainers
        .append("line")
        .attr('id', function (d) {
            return d.source + "-" + d.target;
        })
        .attr('stroke-width', '5px')
        .attr('stroke', '#D3D3D3')
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));
    ;

    var sourceLinkTexts = linkContainers
        .append('text')
        .attr("fill", "Black")
        .attr('x', function (d) {
            return d.source.x;
        })
        .attr('y', function (d) {
            return d.source.y;
        })
        .text(function (d, i) {
            // console.log(d)
            return d.multiplicity[0] + '';
        })
    var destLinkTexts = linkContainers
        .append('text')
        .attr("fill", "Black")
        .attr('x', function (d) {
            return d.target.x;
        })
        .attr('y', function (d) {
            return d.target.y;
        })
        .text(function (d, i) {
            console.log(d)
            return d.multiplicity[1];
        })

    //list of node containers
    var dataEnter = svg
        .attr("class", "nodes")
        .append("g")
        .attr('id', 'nodes')
        .selectAll("g")
        .data(graph.nodes)
        .enter()
        .append("g")
        // .join('g')
        .attr('id', function (d) {
            return 'node_container_' + d.id
        })
    ;

    var schema = schemaarea
        .selectAll("div")
        .data(graph.nodes)
        .enter()
        .append("div")
        .attr('id', function (d) {
            return d.id;
        })


    schema.append("text")
        .style("font-weight", "bold")
        .text(function (d) {
            return d.id + ": ";
        })


    schema.selectAll("span")
        .data(function (d) {
            return d.attributes;
        })
        .enter()
        .append("span")
        .attr('id', function (d) {
            return d.id;
        })
        .text(function (d) {
            return d + ", ";
        })

    var node = dataEnter.append("rect")
        .attr('x', 10)
        .attr('y', 120)
        .attr('id', function (d) {
            return d.id;
        })
        .attr('width', defaultAttrWidth)
        .attr('height', attrHeight)
        // .attr('class', 'table_names')
        // table header color
        .attr('fill', '#bbb')
        .attr('stroke', '#bbb')
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));
    var nodeText = dataEnter.append("text")
        .attr('x', 10)
        .attr('y', 120)
        .attr("dy", "1em")
        .attr('fill', 'white')
        .text(function (d) {
            return d.id;
        })
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

    function getAttributeClassName(d) {
        let measurement_names = this.parentNode.__data__.measurements.flatMap(e => e.name)
        if (this.parentNode.__data__.join_keys.includes(d)) {
            return "join_keys"
        } else if (measurement_names.includes(d)) {
            return "measurements"
        }
        return "attribute";
    }

    function getDefaultAttributeColor(d) {
        let measurement_names = this.parentNode.__data__.measurements.flatMap(e => e.name)
        if (this.parentNode.__data__.join_keys.includes(d)) {
            return defaultJoinKeyColor
        } else if (measurement_names.includes(d)) {
            return defaultMeasurementColor
        }
        return '#fff'
    }

    var attrRects = dataEnter.append('g')
        // .append('rect')
        .selectAll('rect')
        .data(function (d) {
            return d.attributes
        })
        .enter()
        .append('rect')
        .attr('x', 10)
        .attr('y', 120)
        .attr('dy', function (d, i) {
            return 3 * i + 'em'
        })
        .attr('id', function (d, i) {
            return "attr_" + d;
        })
        .attr('class', function (d, i) {
            return getAttributeClassName.call(this, d);
        })
        .attr('width', 60)
        .attr('height', 30)
        .attr('fill', function (d) {
            return getDefaultAttributeColor.call(this, d);
        })
        .attr('stroke', '#bbb')
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

    var attrTexts = dataEnter.select('g')
        .selectAll('text')
        .data(function (d) {
            return d.attributes
        })
        .enter()
        .append('text')
        .attr('class', 'attr_texts')
        .attr('x', 10)
        .attr('y', 120)
        .attr('dy', function (d, i) {
            return (i + 1) * 15;
        })
        .text(function (d) {
            return d;
        })
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

    node.attr("width", function (d) {
        return getMaxComputedTextLength.call(this, trueTypeOf);
    });
    attrRects.attr("width", function (d) {
        return getMaxComputedFromParents.call(this, trueTypeOf);
    });

    simulation
        .nodes(graph.nodes)
        .on("tick", ticked);

    simulation.force("link")
        .links(graph.links)
        .distance(linkDistance);

    // .distance(function(d) {return d.value;});

    function ticked() {
        link
            .attr("x1", function (d) {
                return Math.max(0, Math.min(width, d.source.x));
            })
            .attr("y1", function (d) {
                return Math.max(0, Math.min(height, d.source.y));
            })
            .attr("x2", function (d) {
                return Math.max(0, Math.min(width, d.target.x));
            })
            .attr("y2", function (d) {
                return Math.max(0, Math.min(height, d.target.y));
            });
        sourceLinkTexts
            .attr('x', function (d) {
                return d.source.x + 2* (d.target.x - d.source.x) / 5
            })
            .attr('y', function (d) {
                return d.source.y + 2* (d.target.y - d.source.y) / 5
            });
        destLinkTexts
            .attr('x', function (d) {
                return d.source.x + 3 * (d.target.x - d.source.x) / 5
            })
            .attr('y', function (d) {
                return d.source.y + 3 * (d.target.y - d.source.y) / 5
            });

        node
            .attr("x", function (d) {
                return Math.max(0, Math.min(width, d.x)) - this.getBBox().width / 2;
            })
            .attr("y", function (d) {
                return Math.max(0, Math.min(height, d.y)) - this.getBBox().height / 2;
            });
        nodeText
            .attr("x", function (d) {
                return Math.max(0, Math.min(width, d.x)) - this.getBBox().width / 2;
            })
            .attr("y", function (d) {
                return Math.max(0, Math.min(height, d.y)) - this.getBBox().height / 2;
            });

        attrRects
            .attr("x", function (d, i) {
                return Math.max(0, Math.min(width, this.parentNode.__data__.x)) - this.getBBox().width / 2;
            })
            .attr("y", function (d, i) {
                return Math.max(0, Math.min(height, this.parentNode.__data__.y + 30 * i)) - this.getBBox().height / 2 + 30;
            });

        attrTexts
            .attr("x", function (d, i) {
                return Math.max(0, Math.min(width, this.parentNode.__data__.x)) - this.getBBox().width / 2;
            })
            .attr("y", function (d, i) {
                return Math.max(0, Math.min(height, this.parentNode.__data__.y + 15 * i)) - this.getBBox().height / 2 + 30;
            });

    }

    function resetHighlightingToDefault() {
        svg.selectAll("rect")
            .attr("stroke-width", '1px')
            .attr('stroke', '#D3D3D3')

        svg.selectAll("line")
            .style("stroke-width", '5px')
            .style('stroke', '#D3D3D3')

        schemaarea.selectAll("span")
            .style("color", null)

        // remove highlighting for all attributes of each relation node
        svg.select("#nodes").selectAll('g').selectAll('g').selectAll('text').attr('fill', '#000')


        schemaarea.selectAll("div")
            .style("color", null)
    }

    function dragstarted(d, i) {
        console.log(d)
        //prevent parent svg event from being fired
        d3.event.sourceEvent.stopPropagation();
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        //moving parent node also, if this is a row text element
        if (trueTypeOf(d) === 'string') {
            this.parentNode.__data__.fx = d.x;
            this.parentNode.__data__.fy = d.y;
        }
        d.fx = d.x;
        d.fy = d.y;

        // TODO: move all to style from attr
        // highlight all
        resetHighlightingToDefault();

        if (trueTypeOf(d) === 'string') {
            // if attr is measurement, go through all relations and edges and check if we should highlight them
            // console.log(this.parentNode.__data__)
            let measures = this.parentNode.__data__.measurements;
            let measurement_names = measures.flatMap(e => e.name);
            if (measurement_names.includes(d)) {
                for (let i = 0; i < measures.length; i++) {
                    if (measures[i].name === d) {
                        let rels = measures[i].relations;
                        let edges = measures[i].edges;
                        rels.forEach(function (item) {
                            let color = 'black';
                            if (item.should_highlight === 'True') {
                                if (item.color !== 'None') {
                                    color = item.color
                                }
                                svg.select('#node_container_' + item.name).selectAll('rect').attr('stroke', color)
                            }
                        });
                        edges.forEach(function (item) {
                            let color = 'black';
                            if (item.should_highlight === 'True') {
                                if (item.color !== 'None') {
                                    color = item.color
                                }
                                svg.selectAll("line")
                                    .filter(function (cur_d) { return cur_d.source.id === item.left_rel && cur_d.target.id === item.right_rel;
                                    }).style("stroke", color)
                            }
                        });

                    }
                }
            }
        } else if ("id" in d) {
            // highlight rect
            svg.selectAll("rect").filter(function (cur_d) {
                return cur_d.id == d.id;
            })
                .attr("stroke-width", "3px")
            // highlight text
            schemaarea.select("#" + d.id)
                .style("color", "#009efd")
        } else {
            // highlight line
            svg.selectAll("line").filter(function (cur_d) {
                return cur_d.source == d.source && cur_d.target == d.target;
            })
                .style("stroke", "black")


            //highlighting the relations attached to this edge
            svg.select('#node_container_' + d.source.id).selectAll('rect').attr('stroke', 'black')
            svg.select('#node_container_' + d.target.id).selectAll('rect').attr('stroke', 'black')


            svg.select("#node_container_" + d.source.id).selectAll('g').selectAll('text').filter(function (cur_d) {
                return d.left_keys.includes(cur_d);
            }).attr("fill", "#009efd")
            svg.select("#node_container_" + d.target.id).selectAll('g').selectAll('text').filter(function (cur_d) {
                return d.right_keys.includes(cur_d);
            }).attr("fill", "#009efd")


            schemaarea.select("#" + d.source.id).selectAll("span")
                .filter(function (cur_d) {
                    return d.left_keys.includes(cur_d);
                })
                .style("color", "#009efd")

            schemaarea.select("#" + d.target.id).selectAll("span")
                .filter(function (cur_d) {
                    return d.right_keys.includes(cur_d);
                })
                .style("color", "#009efd")
        }

    }

    function dragged(d, i) {
        d3.event.sourceEvent.stopPropagation();
        //moving parent node also, if this is a row text element
        if (trueTypeOf(d) === 'string') {
            this.parentNode.__data__.fx = d3.event.x
            this.parentNode.__data__.fy = d3.event.y - (i + 1) * 30;
        }
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        d3.event.sourceEvent.stopPropagation();
        if (!d3.event.active) simulation.alphaTarget(0);
        // handle drag on attribute text
        if (trueTypeOf(d) === 'string') {
            this.parentNode.__data__.fx = null
            this.parentNode.__data__.fy = null
        }
        d.fx = null;
        d.fy = null;
    }

    ;

</script>